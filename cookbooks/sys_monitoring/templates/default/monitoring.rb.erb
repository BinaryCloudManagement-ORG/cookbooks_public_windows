#
# Copyright (c) 2010 RightScale Inc
#
# Permission is hereby granted, free of charge, to any person obtaining
# a copy of this software and associated documentation files (the
# "Software"), to deal in the Software without restriction, including
# without limitation the rights to use, copy, modify, merge, publish,
# distribute, sublicense, and/or sell copies of the Software, and to
# permit persons to whom the Software is furnished to do so, subject to
# the following conditions:
#
# The above copyright notice and this permission notice shall be
# included in all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
# EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
# MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
# NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
# LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
# OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
# WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

require 'rubygems'
require 'rubygems/dependency_installer'
require 'logger'
require 'eventmachine'
require 'fileutils'
require 'win32ole'
require File.expand_path(File.join(File.dirname(__FILE__), '..', '..', 'Sandbox', 'right_link', 'config', 'platform'))
require File.join(File.dirname(__FILE__), 'lib', 'collectd', 'collectd')

module RightScale

  class WindowsMonitor

    RS_HOST_PORT      = 3011 # RightScale collectd server port
    SAMPLING_INTERVAL = 20   # Interval in seconds between two sampling
    MAX_EXCEPTIONS    = 3    # Maximum number of exceptions before aborting monitoring
    EXCEPTIONS_EXPIRY = 60   # Number of seconds after which exceptions counter gets reset
    TEMP_DIR          = File.join(ENV['TEMP'], 'RightScale')
    PID_FILE          = File.join(TEMP_DIR, 'monitoring.pid')

    RAW_PERCENTAGE_TO_COLLECTD_DIVISOR = 100000  # divisor to convert from 100Ns to 10ms

    # Check whether monitoring is already running and if not start it
    def self.start
      begin
        if File.exists?(PID_FILE)
          pid = IO.read(PID_FILE).to_i rescue -1
          alive = Process.kill(0, pid) && true rescue false
          return if alive
          File.delete(PID_FILE)
        end
        unless File.exists?(PID_FILE)
          FileUtils.mkdir_p(TEMP_DIR)
          File.open(PID_FILE, 'w') { |f| f.print Process.pid }
          mon = WindowsMonitor.new
          mon.start
        end
      rescue Exception => e
        File.open(File.join(TEMP_DIR, 'monitoring_errors.log'), 'a') { |f| f.puts "Monitoring plugin failed to start:\n#{e.class}: #{e.message}\n#{e.backtrace.join("\n")}" }
        puts "Monitoring plugin failed to start:\n#{e.class}: #{e.message}\n#{e.backtrace.join("\n")}"
        raise e
      end
    end

    # Stop monitoring if it's running
    # Delete pid file, running process will realize it's gone and exit
    def self.stop
      File.delete(PID_FILE) if File.exists?(PID_FILE)
      sleep 1
    end

    # Start monitoring, do nothing if already monitoring
    #
    # === Return
    # Does not return unless more than MAX_EXCEPTIONS exception get raised in
    # less than EXCEPTIONS_EXPIRY seconds
    #
    # === Raise
    # Exception:: If user data is missing
    def start
      unless EM.reactor_running?
        @wmi = WIN32OLE.connect('winmgmts://')
        @iteration = 0
        log_file = File.join(TEMP_DIR, 'monitoring.log')
        @logger = Logger.new(log_file)
        @logger.level = Logger::INFO
        require File.join(RightScale::Platform.filesystem.spool_dir, 'ec2', 'user-data')

        # create collectd connection to our server.
        @collectd = Collectd.new(server = ENV['RS_SKETCHY'],
                                 port = RS_HOST_PORT,
                                 host = '<%= @node[:rightscale][:instance_uuid] %>',
                                 interval = SAMPLING_INTERVAL)
        @last_cpus = nil
        @logger.info('Windows monitoring starting')
        EM.run do
          EM.add_periodic_timer(0.5) { stop unless File.exists?(PID_FILE) }
          EM.add_wall_clock_periodic_timer(SAMPLING_INTERVAL) do
            run_once
          end
        end
        @logger.info('Windows monitoring stopping')
      end
      true
    end

    # Stop monitoring, do nothing if not monitoring
    #
    # === Return
    # true:: Always return true
    def stop
      EM.stop if EM.reactor_running?
      true
    end

    protected

    # Single monitoring iteration
    #
    # === Return
    # true:: Always return true
    def run_once
      @iteration += 1

      @now_time = Time.now.to_i
      @collectd.start(@now_time)

      add_cpu_load
      add_memory_usage
      add_disk_usage

      # flush and send
      @collectd.flush
    end

    # Normalizes the given value from WMI raw percentage units to collectd units.
    #
    # === Parameters
    # raw_value(string):: value to normalize
    #
    # === Returns
    # normal_value(int):: normalized value
    def normalize_raw_value(raw_value)
      return (raw_value.to_f / RAW_PERCENTAGE_TO_COLLECTD_DIVISOR.to_f).round
    end

    # Calculates percentage from the change in value for a percentage-type WMI
    # value using the timestamps read from WMI.
    #
    # === Parameters
    # value_key(token):: key of value to calculate change
    # new_values(Hash):: hash of new values
    # old_values(Hash):: hash of old values
    #
    # === Returns
    # percentage(float):: calculated value as a percentage to two decimals
    def calculate_wmi_percentage(value_key, new_values, old_values)
      return (10000.0 * (new_values[value_key] - old_values[value_key]) / (new_values[:wmi_time] - old_values[:wmi_time])).round / 100.0
    end

    # Calculates percentage from the change in value for a percentage-type WMI
    # value using the timestamps sent by collectd.
    #
    # === Parameters
    # value_key(token):: key of value to calculate change
    # new_values(Hash):: hash of new values
    # old_values(Hash):: hash of old values
    #
    # === Returns
    # percentage(float):: calculated value as a percentage to two decimals
    def calculate_collectd_percentage(value_key, new_values, old_values)
      return (100.0 * (new_values[value_key] - old_values[value_key]) / (new_values[:clock_time] - old_values[:clock_time])).round / 100.0
    end

    # Collect and send CPU load information
    #
    # === Return
    # true:: Always return true
    def add_cpu_load
      begin
        wmi_processor_attributes = ['Name',
                                    'TimeStamp_Sys100NS',
                                    'PercentIdleTime',
                                    'PercentUserTime',
                                    'PercentPrivilegedTime',
                                    'PercentInterruptTime']
        wmi_query = "Select #{wmi_processor_attributes.join(", ")} from Win32_PerfRawData_PerfOS_Processor where Name != '_Total'"
        @logger.debug("WMI query = #{wmi_query}")
        wmi_result = @wmi.execquery(wmi_query)
        cpus = {}
        for cpu in wmi_result do
          cpu_name = cpu.Name
          cpu_values = {}
          cpus[cpu_name] = cpu_values

          cpu_values[:idle] = normalize_raw_value(cpu.PercentIdleTime)
          cpu_values[:interrupt] = normalize_raw_value(cpu.PercentInterruptTime)
          cpu_values[:system] = normalize_raw_value(cpu.PercentPrivilegedTime)
          cpu_values[:user] = normalize_raw_value(cpu.PercentUserTime)

          cpu_values[:wmi_time] = normalize_raw_value(cpu.TimeStamp_Sys100NS)
          cpu_values[:clock_time] = @now_time

          # in WMI, system time includes interrupt and DPC time (deferred
          # procedure calls). subtract out interrupt time so that we can display
          # it separately. DPC is not displayable with Sketchy, so ignore it.
          cpu_values[:system] -= cpu_values[:interrupt]

          # as a sanity check, ensure values are strictly increasing from last
          # sample. this avoids spikes (negative value to unsigned integer)
          # resulting from subtracting interrupt from system (due ultimately to
          # small errors in WMI vs. clock time).
          if @last_cpus && (last_cpu_values = @last_cpus[cpu_name])
            cpu_values.keys.each do |k|
              if cpu_values[k] < last_cpu_values[k]
                cpu_values[k] = last_cpu_values[k]
              end
            end
          end

          # add counters
          @collectd.counter('cpu', cpu_name, 'cpu', 'idle', cpu_values[:idle])
          @collectd.counter('cpu', cpu_name, 'cpu', 'system', cpu_values[:system])
          @collectd.counter('cpu', cpu_name, 'cpu', 'interrupt', cpu_values[:interrupt])
          @collectd.counter('cpu', cpu_name, 'cpu', 'user', cpu_values[:user])

          # logger.
          if @logger.debug?
            @logger.debug("Sending CPU(#{cpu_name}) idle(#{cpu_values[:idle]}) user(#{cpu_values[:user]}) system(#{cpu_values[:system]}) interrupt(#{cpu_values[:interrupt]}) clock(#{cpu_values[:clock_time]})")
            if @last_cpus && (last_cpu_values = @last_cpus[cpu_name])

              # WMI percentages.
              idle_percentage = calculate_wmi_percentage(:idle, cpu_values, last_cpu_values)
              interrupt_percentage = calculate_wmi_percentage(:interrupt, cpu_values, last_cpu_values)
              system_percentage = calculate_wmi_percentage(:system, cpu_values, last_cpu_values)
              user_percentage = calculate_wmi_percentage(:user, cpu_values, last_cpu_values)
              total_percentage = idle_percentage + interrupt_percentage + system_percentage + user_percentage
              delta_time = cpu_values[:wmi_time] - last_cpu_values[:wmi_time]
              @logger.debug("WMI calculation: idle=#{idle_percentage}% user=#{user_percentage}% system=#{system_percentage}% interrupt=#{interrupt_percentage}% total=#{total_percentage}% delta_time=#{delta_time}")

              # collectd percentages.
              idle_percentage = calculate_collectd_percentage(:idle, cpu_values, last_cpu_values)
              interrupt_percentage = calculate_collectd_percentage(:interrupt, cpu_values, last_cpu_values)
              system_percentage = calculate_collectd_percentage(:system, cpu_values, last_cpu_values)
              user_percentage = calculate_collectd_percentage(:user, cpu_values, last_cpu_values)
              total_percentage = idle_percentage + interrupt_percentage + system_percentage + user_percentage
              delta_time = 100 * (cpu_values[:clock_time] - last_cpu_values[:clock_time])
              @logger.debug("collectd calculation: idle=#{idle_percentage}% user=#{user_percentage}% system=#{system_percentage}% interrupt=#{interrupt_percentage}% total=#{total_percentage}% delta_time=#{delta_time}")
            end
          end
        end
        @last_cpus = cpus
      rescue Exception => e
        handle_exception('CPU', e)
      end
      true
    end

    # Collect and send memory usage
    #
    # === Return
    # true:: Always return true
    def add_memory_usage
      begin
        memory = @wmi.execquery("Select FreePhysicalMemory from Win32_OperatingSystem")
        for mem in memory do
          # value returned in kbyte
          free_mem_val = mem.FreePhysicalMemory
          if is_number?(free_mem_val)
            free_mem = free_mem_val.to_i * 1024
            @logger.debug("Sending FreePhysicalMemory: #{free_mem}")
            @collectd.gauge('memory', '', 'memory', 'free', free_mem)
          end
        end
      rescue Exception => e
        handle_exception('Memory', e)
      end
      true
    end

    # Collect and send disk usage
    #
    # === Return
    # true:: Always return true
    def add_disk_usage
      begin
        drives = @wmi.ExecQuery("Select deviceid, freespace, size from win32_logicaldisk")
        for drive in drives do
          if drive.deviceid =~ /^(\w):$/
            drive_letter = $1
            free_space_val = drive.freespace
            drive_size_val = drive.size
            if is_number?(free_space_val) && is_number?(drive_size_val)
              used_space = drive_size_val.to_i - free_space_val.to_i
              @logger.debug("Drive #{drive_letter}: has #{free_space_val} free and #{used_space} used space")
              @collectd.gauge('df', '', 'df', "drive_#{drive_letter}", [ used_space, free_space_val.to_i ])
            end
          end
        end
      rescue Exception => e
        handle_exception('Disk', e)
      end
      true
    end

    # Handle given exception
    # Stop monitoring if more than 3 exceptions occur in less than 1 minute
    #
    # === Parameters
    # title(String):: Title used for logging
    # e(Exception):: Exception being handled
    #
    # === Return
    # true:: Always return true
    def handle_exception(title, e)
      @logger.error("#{title} monitoring failed with #{e.message} from #{e.backtrace.join("\n")}")
      @exceptions_count ||= 0
      @exceptions_count += 1
      if @exceptions_count > MAX_EXCEPTIONS
        stop
      else
        @expiry_timer.cancel if @expiry_timer
        @expiry_timer = EM::Timer.new(EXCEPTIONS_EXPIRY) { @exceptions_count = 0; @expiry_timer = nil }
      end
      true
    end

    # Does given object represent a number?
    # i.e. can o.to_i be safely called
    #
    # === Parameters
    # o(Object):: Object to be tested
    #
    # === Return
    # true:: If o is a number
    # false:: Otherwise
    def is_number?(o)
      res = o && !!o.to_s.match(/\A[+-]?\d+?(\.\d+)?\Z/)
    end

  end

end

if ARGV[0] == '--start'
  RightScale::WindowsMonitor.start
elsif ARGV[0] == '--shutdown'
  RightScale::WindowsMonitor.stop
else
  puts 'Usage: ruby monitoring.rb --start|--shutdown'
end
